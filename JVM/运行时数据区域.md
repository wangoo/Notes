## 运行时数据区域( Run-Time Data Areas)
Java 虚拟机定义了多个数据区域在运行程序时使用。其中一些数据区是在 Java 虚拟机启动时创建的，只有在 Java 虚拟机退出时才会销毁。有些区域则依赖用户线程的启动和结束而创建和销毁。

### 程序计数器（Program Counter Register）
Java 虚拟机可以同时支持多个执行线程。每个JVM线程都有自己的pc register，所以程序计数器是线程私有的。在任何时候，每个Java虚拟机线程都在执行一个方法的代码，即该线程的当前方法。如果该方法不是native的，pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是native的，那么Java虚拟机的pc寄存器的值是undefined。

### Java 虚拟机栈
Java虚拟机栈也是线程私有的，它的生命周期与线程相同。Java虚拟机栈是存储frames(栈帧)的地方。Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧用户存储局部变量表、操作数栈、动态链接、方法出入口等信息。每一个方法从调用直至执行完成的过程就是对应一个栈帧在虚拟机栈中入栈到出栈的过程。

在Java虚拟机栈中有以下异常情况：
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 **StackOverflowError** 异常
- 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出  **OutOfMemoryError** 异常。

### 本地方法栈
本地方法栈与虚拟机栈发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 **StackOverflowError** 异常和 **OutOfMemoryError** 异常。

### Java 堆
Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例，几乎所有类实例和数组的内存都是从这里分配的。Java 堆是垃圾收集管理器管理的主要区域。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 **OutOfMemoryError** 异常。

### 方法区
方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将会抛出 **OutOfMemoryError** 异常。

### 运行时常量池
运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。当常量池无法再申请到内存时会抛出 **OutOfMemoryError** 异常。